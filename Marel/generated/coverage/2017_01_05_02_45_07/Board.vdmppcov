class Board
instance variables
	public grafo_adj : [Grafo] := nil; -- grafo representante do jogo
	
operations
	public Board : () ==> Board Board() == ( 
		grafo_adj := new Grafo();
		buildPossibleMills ();
		return self;
	);
	
	--Mills builder
	public buildPossibleMills : () ==> () buildPossibleMills () == (
		dcl mills : seq of set of nat1:= 
			[{1,2,3},{4,5,6},{7,8,9},{10,11,12},{13,14,15},{16,17,18},
			{19,20,21},{22,23,24},{1,10,22},{4,11,19},{7,12,16},
			{2,5,8},{17,20,23},{9,13,18},{6,14,21},{3,15,24}];
		
		--TODO corrigir comments e verificar este código
		-- para cada vertice
		for all c in set elems grafo_adj.Vertices do (
			dcl mill : seq of nat1 := [];
			-- para cada mill possivel
			for all s in set elems mills do (
				--se o vertice estiver no mill, adicionar os outros dois vertices
				if(c.id in set s)
				then
					--mill := mill ˆ (s\{c.id});
					mill := mill ^ [n | n in set s & n <> c.id];
			);
			c.setMills(mill);
		);
	);
	
	--TODO corrigir comments e verificar este código
	-- Ocupa uma celula com uma peca
	public putPiece : nat1 * Piece ==> () putPiece(idCell, piece) == (
		dcl c : Cell := grafo_adj.Vertices(idCell);
		c.hasPiece := true;
		c.piece := piece;
		c.piece.pieceState := 1;
	)
		--pre pecaX in set (jogador1.pecas union jogador2.pecas); TODO meter no jogo
		pre grafo_adj.Vertices(idCell).hasPiece = false and idCell in set inds (grafo_adj.Vertices)
		post grafo_adj.Vertices(idCell).hasPiece = true;
	
	
end Board